# 웹팩

## 강의 : [캡틴판교, 프론트엔드 개발자를 위한 웹팩](#https://www.inflearn.com/course/%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9B%B9%ED%8C%A9/dashboard)

## 교안 : [웹팩 핸드북](https://joshua1988.github.io/webpack-guide/)

## 깃허브 : [바로가기](https://github.com/joshua1988/LearnWebpack)

```
제가 만드는 것보다는 캡틴판교님의 인프런 강의에서 설명하는 내용을 추가적으로 덧붙인 정리집입니다.
제공되는 교안인 '웹팩 핸드북'에 더욱 자세한 자료가 나와 있습니다!
```

## 강의에서 다루는 내용

- 프런트엔드 빌드 시스템 (NPM, Webpack)
- 자바스크립트 모듈화 (AMD, CommonJS, ES6 Modules)
- 웹팩 개요 (등장 배경, 철학 등)
- 웹팩 주요 속성 4가지
- 배포 환경에서 알고 있어야 할 웹팩 특징과 설정 등

## 목차

- [Node.js와 NPM](#Node.js와-NPM)
- [웹팩 시작하기](#웹팩-시작하기)
- [웹팩 소개](#웹팩-소개)
- [바벨과 ES6 모듈 문법](#바벨과-ES6-모듈-문법)
- [웹팩의 주요 속성 4가지](#웹팩의-주요-속성-4가지)
- [웹팩 데브 서버](#웹팩-데브-서버)

## Node.js와 NPM

### node 버전 확인하기

```
node -v
```

### npm 패키지 초기화하기

```
npm init / npm init -y (간단히)
```

### 라이브러리 설치하기

```
npm install 라이브러리명 / yarn add

npm install axios
```

### 라이브러리 제거하기

```
npm uninstall 라이브러리 명 / yarn remove

npm uninstall axios
```

### NPM 전역으로 설치하기 (--global)

```
npm install 라이브러리명 --global / npm install 라이브러리명 -g

npm install axios --global
```

전역으로 설치할 경우, 시스템 레벨에서 확인 가능하다. 시스템 레벨에서 사용할 자바스크립트 라이브러리를 설치할 때 사용합니다.

경로 📁 /usr/local/lib/node_modules

```
cd /usr/local/lib/node_modules
open .
```

전역에 설치된 라이브러리의 경우 해당 라이브러리에서 제공하는 cli를 자유롭게 사용할 수 있다는 장점이 있다.

### NPM 지역으로 설치하기 (--save-dev)

```
npm install axios --save-prod / npm i
```

지역 설치 명령어의 경우 명령어 옵션으로 --save-prod 를 붙이지 않아도 동일한 효과가 납니다. 또한 install 대신 i를 사용해도 됩니다.

### NPM 지역 설치 옵션 2가지

지역 설치 명령어의 경우 자주 사용되는 2가지 옵션은 다음과 같습니다.

```
npm install axios --save-prod

npm install axios --save-dev
```

위 명령어는 아래와 같이 각각 축약할 수 있습니다.

```
npm i axios

npm i axios -D
```

① 설치 옵션에 아무것도 넣지 않은 npm i 는 package.json의 dependencies에 등록됩니다.

```
  "dependencies": {
    "axios": "^0.21.4"
  }
```

② 설치 옵션으로 -D를 넣은 경우에는 해당 라이브러리가 package.json의 devDependencies에 등록됩니다.

```
{
  "devDependencies": {
    "axios": "^0.21.4"
  }
}

```

### ① dependencies와 ② devDependencies의 차이점

① dependencies는 애플리케이션의 동작과 관련이 있습니다

```
  "dependencies": {
    "axios": "^0.21.4"
    "react" : "",
  }
```

② devDependencies는 개발을 할 때 도움을 주는 개발용 보조 라이브러리를 의미합니다

```
{
  "devDependencies": {
    "webpack": "",
    "":""
  }
}

```

### ① dependencies와 ② devDependencies 구분하기

설치된 배포용 라이브러리는 npm run build 로 빌드를 하면 최종 애플리케이션 코드 안에 포함됩니다.

그런데 만약 반대로 설치 옵션에 -D를 주었다면 해당 라이브러리는 빌드하고 배포할 때 애플리케이션 코드에서 빠지게 됩니다. 따라서, 최종 애플리케이션에 포함되어야 하는 라이브러리는 -D로 설치하면 안 됩니다. 개발할 때만 사용하고 배포할 때는 빠져도 좋은 라이브러리의 예시는 다음과 같습니다.

```
webpack: 빌드 도구
eslint: 코드 문법 검사 도구
imagemin: 이미지 압축 도구
```

## 웹팩 시작하기

### 웹팩이란?

웹팩이란 최신 프런트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러(Module Bundler)입니다. 모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미합니다.

<img src="./images/bundle.png" alt="bundle">

### 모듈이란?

모듈이란 프로그래밍 관점에서 특정 기능을 갖는 작은 코드 단위를 의미합니다. 자바스크립트로 치면 아래와 같은 코드가 모듈입니다.

```js
// 📁 math.js

function sum(a, b) {
  return a + b;
}

function substract(a, b) {
  return a - b;
}

const PI = 3.14;

export { sum, substract, PI };
```

이 math.js 파일은 아래와 같이 3가지 기능을 갖고 있는 모듈입니다.

- 두 숫자의 합을 구하는 sum() 함수
- 두 숫자의 차를 구하는 substract() 함수
- 원주율 값을 갖는 PI 상수

이처럼 성격이 비슷한 기능들을 하나의 의미있는 파일로 관리하면 모듈이 됩니다.

### 웹팩에서의 모듈

웹팩에서 지칭하는 모듈이라는 개념은 위와 같이 자바스크립트 모듈에만 국한되지 않고 웹 애플리케이션을 구성하는 모든 자원을 의미합니다. 웹 애플리케이션을 제작하려면 HTML, CSS, Javascript, Images, Font 등 많은 파일들이 필요하죠. 이 파일 하나하나가 모두 모듈입니다.

### 모듈 번들링이란?

아래 그림과 같이 웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링이라고 합니다.

파일들의 연관된 관계를 파악하여 파일들을 하나의 파일로 압축시켜주는 과정을 번들링 과정이라 합니다.

<img src="./images/moduleBundling.png" alt="moduleBundling">

## 웹팩 소개

### 웹팩의 등장 배경

웹팩이 등장한 이유는 크게 3가지입니다.

1. 파일 단위의 자바스크립트 모듈 관리의 필요성
2. 웹 개발 작업 자동화 도구
3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능

#### 파일 단위의 자바스크립트 모듈 관리의 필요성

입문자 관점에서 고안된 자바스크립트는 아래와 같이 편리한 유효 범위를 갖고 있습니다.

```js
var window = 10;
console.log(window); // 10

function logText() {
  console.log(window); // 10
}
```

자바스크립트의 변수 유효 범위는 기본적으로 전역 범위를 갖습니다. 최대한 넓은 변수 범위를 갖기 때문에 어디에서도 접근하기가 편리하죠.

그런데 이러한 장점이 실제로 웹 애플리케이션을 개발할 때는 아래와 같은 문제점으로 변합니다.

```html
<!-- index.html -->
<html>
  <head>
    <!-- ... -->
  </head>
  <body>
    <!-- ... -->
    <script src="./app.js"></script>
    <script src="./main.js"></script>
    <script>
      getNum(); // ??
    </script>
  </body>
</html>
```

각각 다른 파일(app, main)에서 의도치 않게 같은 함수를 정의하고 호출했을 때, index.html에서는 어떤 함수를 불러오게 될까요?

```js
// app.js
var num = 10;
function getNum() {
  console.log(num);
}
```

```js
// main.js
var num = 20;
function getNum() {
  console.log(num);
}
```

결과는 가장 나중에 불러오게 되는 script 파일인 main.js에 선언된 값 20입니다.

app.js에서 선언한 num 변수는 main.js에서 다시 선언하고 20을 할당했기 때문이죠.

이러한 문제점은 실제로 복잡한 애플리케이션을 개발할 때 발생합니다. 변수의 이름을 모두 기억하지 않은 이상 변수를 중복 선언하거나 의도치 않은 값을 할당할 수 있죠.

이처럼 파일 단위로 변수를 관리하고 싶은 욕구, 자바스크립트 모듈화에 대한 욕구를 예전까진 AMD, Common.js와 같은 라이브러리로 풀어왔습니다.

#### 웹 개발 작업 자동화 도구

이전부터 프런트엔드 개발 업무를 할 때 가장 많이 반복하는 작업은 텍스트 편집기에서 코드를 수정하고 저장한 뒤 브라우저에서 새로 고침을 누르는 것이었습니다. 그래야 화면에 변경된 내용을 볼 수 있었죠.

이외에도 웹 서비스를 개발하고 웹 서버에 배포할 때 아래와 같은 작업들을 해야 했습니다.

- HTML, CSS, JS 압축
- 이미지 압축
- CSS 전처리기 변환

이러한 일들을 자동화 해주는 도구들이 필요했습니다. 그래서 Grunt와 Gulp 같은 도구들이 등장했습니다.

#### 웹 애플리케이션의 빠른 로딩 속도와 높은 성능

일반적으로 특정 웹 사이트를 접근할 때 5초 이내로 웹 사이트가 표시되지 않으면 대부분의 사용자들은 해당 사이트를 벗어나거나 집중력을 잃게 됩니다.

그래서 웹 사이트의 로딩 속도를 높이기 위해 많은 노력들이 있었습니다. 그 중 대표적인 노력이 브라우저에서 서버로 요청하는 파일 숫자를 줄이는 것입니다. 이를 위해 앞에서 살펴본 웹 태스크 매니저를 이용해 파일들을 압축하고 병합하는 작업들을 진행했습니다.

뿐만 아니라 초기 페이지 로딩 속도를 높이기 위해 나중에 필요한 자원들은 나중에 요청하는 레이지 로딩(Lazy Loading)이 등장했죠.

웹팩은 기본적으로 필요한 자원은 미리 로딩하는게 아니라 그 때 그 때 요청하자는 철학을 갖고 있습니다.

#### 🔥 [유튜브 링크: Webpack from First Principles](https://www.youtube.com/watch?v=WQue1AN93YU)

여기 해당 버튼을 클릭하면 크로커다일을 불러오는 웹 애플리케이션이 있습니다.

구조는 다음과 같습니다. (tree 참조)

<img src="./images/tree.png">

해당 애플리케이션의 리소스를 불러오는 요청 과정에서 쓰로틀링이 생기지 않는 쾌적한 환경일 경우, 약 100ms (0.1초) 밖에 걸리지 않습니다.

디렉토리별로 각각의 파일이 존재하지만, 쾌적한 환경에서는 시간이 얼마 걸리지 않습니다.

#### 💨 쾌적한 환경 (non throttle)

<img src="./images/noThrottle.gif">

하지만 지구 반대편에서 해당 애플리케이션에 접근한다면 인터넷 속도 등의 다양한 외부요인에 의해 리소스를 불러오는 과정에 시간이 오래 걸릴 수 있습니다.

#### 🔥 쾌적하지 않은 환경 (throttle)

<img src="./images/Throttle.gif">

약 1300ms (1.3)초 가량으로 늘어난 것을 볼 수 있습니다.

이렇게 인터넷 환경에 따라 서버로부터 전달 받은 리소스 (html/css/js/ svg / ..) 들을 화면에 렌더링할 때 각각의 파일로 저장되어 있다면, 결과적으로 불러오는데 시간이 오래 걸릴 수 있습니다.

이런 상황을 해결하기 위해 우리는 webpack을 사용합니다.

<img src="./images/bundling.png" alt="bundling">

웹팩의 번들링 과정을 통해서 각 파일을 bundle.js에 몰아서 넣었고, 번들링된 bundle.js에서 각 모듈을 불러오니, 파일에 각각 접근하는 것보다 시간이 훨씬 절약됩니다. 이것이 우리가 웹팩을 사용하는 이유입니다.

### 웹팩으로 해결하려는 문제 ?

웹팩의 등장 배경에서도 살펴봤지만 웹팩에서 해결하고자 하는 기존의 문제점은 다음 4가지 입니다.

- 자바스크립트 변수 유효 범위
- 브라우저별 HTTP 요청 숫자의 제약
- 사용하지 않는 코드의 관리

#### 자바스크립트 변수 유효 범위 문제

웹팩은 변수 유효 범위의 문제점을 ES6의 Modules 문법과 웹팩의 모듈 번들링으로 해결합니다.

#### 브라우저별 HTTP 요청 숫자의 제약

TCP 스펙에 따라 브라우저에서 한 번에 서버로 보낼 수 있는 HTTP 요청 숫자는 제약되어 있습니다. 아래의 표는 최신 브라우저 별 최대 HTTP 요청 횟수입니다.

| 브라우저          | 최대 연결 횟수 |
| :---------------- | :------------- |
| 익스플로러 7      | 2              |
| 익스플로러 8, 9   | 6              |
| 익스플로러 10, 11 | 8, 13          |
| 크롬              | 6              |
| 사파리            | 6              |
| 파이어폭스        | 6              |
| 오페라            | 6              |
| 안드로이드, ios   | 6              |

따라서, HTTP 요청 숫자를 줄이는 것이 웹 애플리케이션의 성능을 높여줄 뿐만 아니라 사용자가 사이트를 조작하는 시간을 앞당겨 줄 수 있습니다.

## 바벨과 ES6 모듈 문법

## 웹팩의 주요 속성 4가지

## 웹팩 데브 서버
